# -*- coding: utf-8 -*-
#Boa:Frame:TFrame

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#                      Python Adventure Writing System                          #
#                       wxPython Terminal Support Code                          #
#                     Written by Roger Plowman (c) 2008                         #
#                                                                               #
# The C="""...""" statements scattered throughout this source code are actually #
# a work-around for Python's lack of block comments. Notepad++ can only fold    #
# block comments, not a series of comment lines. Using C="""...""" doesn't      #
# increase PAWS memory footprint, although it does have a tiny impact           #
# on loading time.                                                              #
#                                                                               #
C="""
  This module contains the bulk of the terminal program. Portions of this
  program were generated by the Boa Constructor IDE, other parts were
  written by me. Note it does NOT follow PAWS style guidelines, because the
  Boa Constructor IDE generated large portions of the program. Imposing the
  guidelines could confuse the code generator in the IDE, causing this
  program to fail.

  Written By: Roger Plowman
  Written On: 01/20/2008
  """
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

#********************************************************************************
#                                 Library Imports
#
C="""
  We need some standard Python libraries. These aren't part of PAWS, rather
  they're supplied as part of Python. It's good programming practice not to
  "re-invent the wheel" when you don't have to, so always look for a pre-written
  library to do your work for you!
  """

import wx
from wx.lib.anchors import LayoutAnchors
from wx.lib.wordwrap import wordwrap

from Core import *
from Universe import *

def create(parent):
    return TFrame(parent)

[wxID_TFRAME, wxID_TFRAMETDISPLAY, wxID_TFRAMETINPUT, wxID_TFRAMETSTATUSBAR,
] = [wx.NewId() for _init_ctrls in range(4)]

[wxID_TFRAMEMENUFILEDEBUG, wxID_TFRAMEMENUFILEEXIT, wxID_TFRAMEMENUFILEITEMS2,
 wxID_TFRAMEMENUFILELOGGAME, wxID_TFRAMEMENUFILEPLAYGAME,
 wxID_TFRAMEMENUFILESAVE, wxID_TFRAMEMENUFILETERSE,
 wxID_TFRAMEMENUFILEVERBOSE,
] = [wx.NewId() for _init_coll_menuFile_Items in range(8)]

[wxID_TFRAMEMENUHELPABOUT, wxID_TFRAMEMENUHELPHINTS,
] = [wx.NewId() for _init_coll_menuHelp_Items in range(2)]

[wxID_TFRAMEMENUVIEWFONT] = [wx.NewId() for _init_coll_menuView_Items in range(1)]

class TFrame(wx.Frame):
    def _init_coll_flexGridSizer1_Items(self, parent):
        # generated method, don't edit

        parent.AddWindow(self.TDisplay, 0, border=0, flag=wx.GROW | wx.EXPAND)
        parent.AddWindow(self.TInput, 1, border=1,
              flag=wx.GROW | wx.RIGHT | wx.LEFT | wx.EXPAND | wx.ALIGN_BOTTOM)

    def _init_coll_flexGridSizer1_Growables(self, parent):
        # generated method, don't edit

        parent.AddGrowableRow(0)
        parent.AddGrowableCol(0)

    def _init_coll_TMenuBar_Menus(self, parent):
        # generated method, don't edit

        parent.Append(menu=self.menuFile, title=u'&File')
        parent.Append(menu=self.menuView, title=u'&View')
        parent.Append(menu=self.menuHelp, title=u'&Help')

    def _init_coll_menuFile_Items(self, parent):
        # generated method, don't edit

        parent.Append(help='', id=wxID_TFRAMEMENUFILEPLAYGAME,
              kind=wx.ITEM_NORMAL, text=u'Pick Game …')
        parent.AppendSeparator()
        parent.Append(help='', id=wxID_TFRAMEMENUFILESAVE, kind=wx.ITEM_NORMAL,
              text=u'Save')
        parent.Append(help='', id=wxID_TFRAMEMENUFILEITEMS2,
              kind=wx.ITEM_NORMAL, text=u'Restore')
        parent.AppendSeparator()
        parent.Append(help='', id=wxID_TFRAMEMENUFILEDEBUG, kind=wx.ITEM_NORMAL,
              text=u'Debug')
        parent.Append(help='', id=wxID_TFRAMEMENUFILELOGGAME,
              kind=wx.ITEM_NORMAL, text=u'Log Game')
        parent.AppendSeparator()
        parent.Append(help='', id=wxID_TFRAMEMENUFILEVERBOSE,
              kind=wx.ITEM_NORMAL, text=u'Verbose')
        parent.Append(help='', id=wxID_TFRAMEMENUFILETERSE, kind=wx.ITEM_NORMAL,
              text=u'Terse')
        parent.AppendSeparator()
        parent.Append(help='', id=wxID_TFRAMEMENUFILEEXIT, kind=wx.ITEM_NORMAL,
              text=u'E&xit')
        self.Bind(wx.EVT_MENU, self.OnMenuFileSaveMenu,
              id=wxID_TFRAMEMENUFILESAVE)
        self.Bind(wx.EVT_MENU, self.OnMenuFileItems2Menu,
              id=wxID_TFRAMEMENUFILEITEMS2)
        self.Bind(wx.EVT_MENU, self.OnMenuFileDebugMenu,
              id=wxID_TFRAMEMENUFILEDEBUG)
        self.Bind(wx.EVT_MENU, self.OnMenuFileLoggameMenu,
              id=wxID_TFRAMEMENUFILELOGGAME)
        self.Bind(wx.EVT_MENU, self.OnMenuFileVerboseMenu,
              id=wxID_TFRAMEMENUFILEVERBOSE)
        self.Bind(wx.EVT_MENU, self.OnMenuFileTerseMenu,
              id=wxID_TFRAMEMENUFILETERSE)
        self.Bind(wx.EVT_MENU, self.OnMenuFileExitMenu,
              id=wxID_TFRAMEMENUFILEEXIT)
        self.Bind(wx.EVT_MENU, self.OnMenuFilePlaygameMenu,
              id=wxID_TFRAMEMENUFILEPLAYGAME)

    def _init_coll_menuView_Items(self, parent):
        # generated method, don't edit

        parent.Append(help='', id=wxID_TFRAMEMENUVIEWFONT, kind=wx.ITEM_NORMAL,
              text=u'Font …')
        self.Bind(wx.EVT_MENU, self.OnMenuViewFontMenu,
              id=wxID_TFRAMEMENUVIEWFONT)

    def _init_coll_menuHelp_Items(self, parent):
        # generated method, don't edit

        parent.Append(help='', id=wxID_TFRAMEMENUHELPHINTS, kind=wx.ITEM_NORMAL,
              text=u'Hints')
        parent.Append(help='', id=wxID_TFRAMEMENUHELPABOUT, kind=wx.ITEM_NORMAL,
              text=u'About PAWS')
        self.Bind(wx.EVT_MENU, self.OnMenuHelpHintsMenu,
              id=wxID_TFRAMEMENUHELPHINTS)
        self.Bind(wx.EVT_MENU, self.OnMenuHelpAboutMenu,
              id=wxID_TFRAMEMENUHELPABOUT)

    def _init_coll_TStatusBar_Fields(self, parent):
        # generated method, don't edit
        parent.SetFieldsCount(1)

        parent.SetStatusText(number=0, text=u'Status Bar Info Goes Here')

        parent.SetStatusWidths([-1])

    def _init_sizers(self):
        # generated method, don't edit
        self.flexGridSizer1 = wx.FlexGridSizer(cols=1, hgap=0, rows=2, vgap=0)
        self.flexGridSizer1.SetMinSize(wx.Size(200, 121))
        self.flexGridSizer1.SetNonFlexibleGrowMode(wx.FLEX_GROWMODE_SPECIFIED)

        self._init_coll_flexGridSizer1_Growables(self.flexGridSizer1)
        self._init_coll_flexGridSizer1_Items(self.flexGridSizer1)

        self.SetSizer(self.flexGridSizer1)

    def _init_utils(self):
        # generated method, don't edit
        self.menuFile = wx.Menu(title=u'')

        self.menuView = wx.Menu(title=u'')

        self.menuHelp = wx.Menu(title=u'')

        self.TMenuBar = wx.MenuBar()

        self._init_coll_menuFile_Items(self.menuFile)
        self._init_coll_menuView_Items(self.menuView)
        self._init_coll_menuHelp_Items(self.menuHelp)
        self._init_coll_TMenuBar_Menus(self.TMenuBar)

    def _init_ctrls(self, prnt):
        # generated method, don't edit
        wx.Frame.__init__(self, id=wxID_TFRAME, name='TFrame', parent=prnt,
              pos=wx.Point(254, 241), size=wx.Size(829, 786),
              style=wx.DEFAULT_FRAME_STYLE, title=u'PAWS Terminal')
        self._init_utils()
        self.SetClientSize(wx.Size(821, 748))
        self.SetMenuBar(self.TMenuBar)
        self.SetAutoLayout(True)
        self.SetToolTipString('TFrame')
        self.SetMinSize(wx.Size(-1, 21))

        self.TStatusBar = wx.StatusBar(id=wxID_TFRAMETSTATUSBAR,
              name='TStatusBar', parent=self, style=0)
        self.TStatusBar.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, False,
              u'Courier New'))
        self._init_coll_TStatusBar_Fields(self.TStatusBar)
        self.SetStatusBar(self.TStatusBar)

        self.TInput = wx.TextCtrl(id=wxID_TFRAMETINPUT, name='TInput',
              parent=self, pos=wx.Point(1, 728), size=wx.Size(819, 20),
              style=wx.SIMPLE_BORDER | wx.TE_PROCESS_ENTER, value="''")
        self.TInput.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.BOLD, False,
              u'Courier'))
        self.TInput.SetToolTipString(u'Type command here.')
        self.TInput.SetAutoLayout(False)
        self.TInput.SetEditable(True)
        self.TInput.Enable(False)
        self.TInput.Bind(wx.EVT_TEXT_ENTER, self.OnTInputTextEnter,
              id=wxID_TFRAMETINPUT)

        self.TDisplay = wx.TextCtrl(id=wxID_TFRAMETDISPLAY, name='TDisplay',
              parent=self, pos=wx.Point(0, 0), size=wx.Size(821, 728),
              style=wx.TE_RICH2 | wx.TE_MULTILINE | wx.TE_READONLY,
              value=u'To run a game, choose File → Pick Game … then choose a game from the list.')
        self.TDisplay.SetMinSize(wx.Size(517, 440))
        self.TDisplay.SetEditable(False)
        self.TDisplay.SetToolTipString(u"Game's output displays here.")
        self.TDisplay.SetFont(wx.Font(12, wx.SWISS, wx.NORMAL, wx.NORMAL, False,
              u'Arial'))
        self.TDisplay.Enable(True)

        self._init_sizers()

    def __init__(self, parent):
        """Initialize Terminal."""
        self._init_ctrls(parent)


        #-----------------------
        # Get Menu Bar Reference
        #-----------------------

        # wxPython menus are complex, so we need to get a reference to the menu
        # bar before we can refer to the menu items on the menus on the bar. :)

        MB = self.GetMenuBar()

        #-----------------------------
        # Disable Unusuable Menu Items
        #-----------------------------

        # The following menu items can't be used until a game is selected and
        # running. The default for all menu items is enabled, so we have to
        # make them disabled at this point (before the menu can be used).

        MB.Enable(wxID_TFRAMEMENUFILESAVE,False)
        MB.Enable(wxID_TFRAMEMENUFILEITEMS2,False)
        MB.Enable(wxID_TFRAMEMENUFILEDEBUG,False)
        MB.Enable(wxID_TFRAMEMENUFILELOGGAME,False)
        MB.Enable(wxID_TFRAMEMENUFILEVERBOSE,False)
        MB.Enable(wxID_TFRAMEMENUFILETERSE,False)
        # MB.Enable(wxID_TFRAMEMENUVIEWFONT,False)
        MB.Enable(wxID_TFRAMEMENUHELPHINTS,False)

    def OnMenuFileSaveMenu(self, event):
        """
        This function is run when Save is clicked on the menu. All it does
        is call the terminal's Feed function to emulate the player typing
        a command.
        """

        Terminal.Feed(u"save")
        # event.Skip()

    def OnMenuFileItems2Menu(self, event):
        """
        This function is run when Restore is clicked on the menu. All it does
        is call the terminal's Feed function to emulate the player typing
        a command.
        """

        Terminal.Feed(u"restore")
        # event.Skip()

    def OnMenuFileDebugMenu(self, event):
        """
        This function is run when Debug is clicked on the menu. All it does
        is call the terminal's Feed function to emulate the player typing
        a command.
        """

        Terminal.Feed(u"debug")
        # event.Skip()

    def OnMenuFileLoggameMenu(self, event):
        """
        This function is run when Log Game is clicked on the menu. All it
        does is call the terminal's Feed function to emulate the player
        typing a command.
        """

        Terminal.Feed(u"transcribe")
        # event.Skip()

    def OnMenuFileVerboseMenu(self, event):
        """
        This function is run when Verbose is clicked on the menu. All it
        does is call the terminal's Feed function to emulate the player
        typing a command.
        """

        Terminal.Feed(u"verbose")
        # event.Skip()

    def OnMenuFileTerseMenu(self, event):
        """
        This function is run when Terse is clicked on the menu. All it does
        is call the terminal's Feed function to emulate the player typing
        a command.
        """

        Terminal.Feed(u"terse")
        # event.Skip()

    def OnMenuFileExitMenu(self, event):
        """
        This function is run when Exit is clicked on the menu. All it does
        is close the terminal frame (the window holding the terminal).
        """

        self.Close()
        # event.Skip()

    def OnMenuHelpHintsMenu(self, event):
        """
        This function is run when "Hints" is clicked on the menu. All it
        does is call the terminal's Feed function to emulate the player
        typing a command.
        """

        Terminal.Feed(u"help")
        # event.Skip()

    def OnMenuHelpAboutMenu(self, event):
        """
        This function is run when About is clicked on the menu. It calls
        a standard About dialog window.
        """

        info = wx.AboutDialogInfo()
        info.Name = u"PAWS"
        info.Version = Engine.Version
        info.Copyright = u"© 1998–2016 Roger Plowman, Matthias C. Hormann"
        info.Description = wordwrap(
            u"Core Engine: v" + Engine.Version + u", "
            u"Universe: v" + UniverseVersion + u"\n\n"
            u"PAWS is the Python Adventure Writing System, "
            u"a software to play and develop Interactive Fiction with. "
            u"It was originally developed by Roger Plowman and continued "
            u"in 2016 by Matthias C. Hormann, just for the fun of it.",
            350, wx.ClientDC(self))
        info.WebSite = (u"https://github.com/Moonbase59/PAWS", u"PAWS GitHub page")
        info.Developers = [u"Roger Plowman", u"Kevin Russell", u"Matthias C. Hormann"]
        info.License = wordwrap(
            u"Please see the LICENSE file that came with the software.",
            350, wx.ClientDC(self))

        # show it
        wx.AboutBox(info)
        # event.Skip()

    def OnTInputTextEnter(self, event):
        """
        This function is run when the player presses Enter after typing a
        command.
        """

        #-----------------------------
        # If Player JUST pressed Enter
        #-----------------------------

        # If the player hit the Enter key without typing a command we skip the
        # event (pretend it didn't happen) and return immediately. This allows
        # the player to type another command.

        if not len(self.TInput.GetValue()):
            event.Skip()
            return

        #-----------------------
        # Process Player's Input
        #-----------------------

        # This is the routine that actually processes the player's input,
        # calling the parser, which in turn breaks down the typed command and
        # executes it, thus running the game.

        self.ProcessPlayerInput()
        # event.Skip()

    def OnMenuFilePlaygameMenu(self, event):
        """
        This function is run when Play Game is clicked on the menu.
        """

        #------------------------------
        # Hook Frame into Core Terminal
        #------------------------------

        # This allows the Terminal object in Core to recognize the Frame, which
        # was defined at a higher level. (TerminalFrame imports Core, and thus
        # is "higher" than Core.)

        Terminal.Frame = self

        #----------------------
        # Ready The File Dialog
        #----------------------

        # We want all .py files in the current folder listed. Note the "current
        # folder" is the one containing LoadTerminal.pyy. The reason we gave
        # LoadTerminal a .pyy extension is so it wouldn't show up in the game
        # list.

        dlg = wx.FileDialog(self,
                            u"Choose a game",
                            u".",
                            u"",
                            u"PAWS Games (*.py)|*.py",
                            wx.OPEN)

        #------------------------------
        # Show The Dialog To The Player
        #------------------------------

        # If the player didn't click OK (clicked Cancel instead) then we close
        # the File Open dialog (destroy it) and exit immediately.

        # If they DID click OK we destroy the dialog. Interestingly, destorying
        # the dialog doesn't get rid of it, it just closes it.

        try:
            if dlg.ShowModal() != wx.ID_OK:
                dlg.Destroy()
                return
        finally:
            dlg.Destroy()

        #-------------------------
        # Retrieve the Game's Name
        #-------------------------

        # GameModule now contains the name of the file the player chose, but
        # we leave off the ".py" extension, which is what the [:-3] does.

        Global.GameModule = dlg.GetFilename()[:-3]

        if Global.GameModule == u"LoadTerminal":
            Terminal.Frame.TDisplay.Clear()
            Say(u"~p ~p ~p ~title ~lrd ~b LoadTerminal ~l is not a game.")
            event.Skip()
            return

        #------------------
        # Enable Menu Items
        #------------------

        # Now that the player has chosen a game the menu items we disabled in
        # the __init__() function need to be re-enabled because we're going to
        # need them during the game.

        MB = self.GetMenuBar()
        MB.Enable(wxID_TFRAMEMENUFILESAVE,True)
        MB.Enable(wxID_TFRAMEMENUFILEITEMS2,True)
        MB.Enable(wxID_TFRAMEMENUFILEDEBUG,True)
        MB.Enable(wxID_TFRAMEMENUFILELOGGAME,True)
        MB.Enable(wxID_TFRAMEMENUFILEVERBOSE,True)
        MB.Enable(wxID_TFRAMEMENUFILETERSE,True)
        MB.Enable(wxID_TFRAMEMENUVIEWFONT,True)
        MB.Enable(wxID_TFRAMEMENUHELPHINTS,True)
        MB.Enable(wxID_TFRAMEMENUFILEPLAYGAME,False)

        #---------------------------------
        # Enable The Player's Command Box
        #---------------------------------

        # The long thin text box at the bottom of the terminal is where the
        # player enters their commands. The following 3 lines of code enable the
        # text box, clear it, and move the focus to it so the box is ready to
        # accept text.

        Terminal.Frame.TInput.Enable(True)
        Terminal.Frame.TInput.Clear()
        Terminal.Frame.TInput.SetFocus()
        Terminal.CurrentFont = Terminal.Frame.TDisplay.GetDefaultStyle().GetFont()

        #------------
        # Import Game
        #------------

        # STMT lets us create the import statement we want. For example, if the
        # player chose TQ as their game, STMT will contain "from TQ import *".
        #
        # The exec statement executes STMT as though it were a line in the
        # program. Further, everything that's imported is imported into the
        # global dictionary instead of the local one.
        #
        # That means when this function ends the game you imported doesn't
        # vanish. If you didn't add "in globals()" to the exec statement, the
        # import statement would only last until this function ends--and that's
        # bad.

        STMT = u"from %s import *" % Global.GameModule
        exec STMT in globals()

        #-------------------
        # Start Running Game
        #-------------------

        # Set up the Game and set GameState to RUNNING. Finally, add a command
        # prompt to the display.

        Engine.SetUpGame()
        Global.GameState = RUNNING
        Say(u"~p " + P.AP().Prompt())

        # event.Skip()

    def OnMenuViewFontMenu(self, event):
        """
        Change the font used in the terminal. Called when Font... menu is
        clicked.
        """

        #------------------------------
        # Hook Frame into Core Terminal
        #------------------------------

        # This allows the Terminal object in Core to recognize the Frame, which
        # was defined at a higher level. (TerminalFrame imports Core, and thus
        # is "higher" than Core.) This works whether the Frame has been created
        # or not.

        Terminal.Frame = self

        #----------------------------------------------
        # Create Terminal Display/Terminal Font Synonym
        #----------------------------------------------

        # TD is just a synonym for Terminal.Frame.TDisplay (the terminal's
        # "screen".) TF is a synonym for the TD's font.

        TD = Terminal.Frame.TDisplay
        TF = TD.GetDefaultStyle().GetFont()
        TFD = wx.FontData()

        #------------------------------
        # Create Font Dialog And Set It
        #------------------------------

        # Create the font dialog, passing it the TFD object that will hold the
        # returned font. Then set the initial font to TD's current font.

        Dlg = wx.FontDialog(TD,TFD)
        Dlg.GetFontData().SetInitialFont(TF)

        #----------------
        # Get User's Font
        #----------------

        # Show the font dialog to the player and if the player chooses OK then
        # get the chosen font and put it in TF, then set the terminal's current
        # font pitch (a saved default value) to whatever the font size of the
        # chosen font is.
        #
        # If the player canceled, destroy the dialog and return immediately.

        if Dlg.ShowModal() == wx.ID_OK:
            TF = Dlg.GetFontData().GetChosenFont()
            Terminal.CurrentFontPitch = TF.GetPointSize()
            Terminal.CurrentFont = TF
            Dlg.Destroy()
        else:
            Dlg.Destroy()
            return

        #------------------------
        # Create a Text Attribute
        #------------------------

        # The text attribute is the combination of font, text color, and
        # background color. We need it to set the terminal's font color and
        # style.

        TA = wx.TextAttr(wx.NullColour,wx.NullColour,TF)

        #---------------------------------
        # Change The Terminal's Font Style
        #---------------------------------

        # Set the text attribute of all characters in TD to the current font,
        # from the first character to the last. We also set the default style
        # for new text to the current text attribute.

        TD.SetDefaultStyle(TA)
        TD.SetStyle(0,TD.GetLastPosition(),TA)

    def ProcessPlayerInput(self):
        """
        This function takes the player's typed input and processes it. First
        the parser is called, then the command text box is cleared. Then the
        parsed command is executed.
        """

        #--------------------------
        # Parse Player's Command(s)
        #--------------------------

        # This takes the typed command and performs a full parse. By the time
        # this line is done the typed data has been converted to a known
        # state.
        #
        # The WHILE statement handles the case where the player typed multiple
        # commands on one line.

        P.AP().GetPlayerInput()
        while P.AP().CommandsList:

            #------------------
            # Clear Command Box
            #------------------

            # Once the typed command has been processed we erase the player's
            # command box to ready it for the next command.

            Terminal.Frame.TInput.Clear()

            #-----------------------
            # Handle Pre-Turn Events
            #-----------------------

            # These are any events (usually fuses, daemons, etc) that happen
            # so quickly they occur EVEN IF THE PLAYER'S COMMAND WAS NOT
            # UNDERSTOOD!
            #
            # This includes combat, poison, events that take seconds, etc.

            Engine.PreTurnHandler()

            #-------------------------------
            # If Command Successfully Parsed
            #-------------------------------

            # If the command was successfully parsed the engine calls the
            # turn handler is called. If the turn completed successfully then
            # the AFTER turn handler is called.

            if P.AP().Parser() == SUCCESS:
                if Engine.TurnHandler() == TURN_ENDS:
                    Engine.AfterTurnHandler()

            #-------------------------------------------------
            # One turn finished, put a paragraph in the output
            #-------------------------------------------------

            Say(u"~n ")

            #---------------
            # Game Finished?
            #---------------

            # If the player ended the game by typing quit, or if the game itself
            # decided to end, the Global.GameState property changes from RUNNING
            # to FINISHED.
            #
            # Once the game is finished the post game wrap up is called, then
            # the terminal session is terminated (closing the terminal).

            if Global.GameState == FINISHED:
                Engine.PostGameWrapUp()
                Terminal.Terminate()

        #---------------------------
        # Display The Command Prompt
        #---------------------------

        # For some very odd reason, we can only output this AFTER the event,
        # i.e. display it for the NEXT command ...

        Say(u"~n " + P.AP().Prompt())


#********************************************************************************
#                                  Functions
#

C="""
  These functions must be defined in the module that imports PAWS, Universe,
  and your game to work properly, this has to do with the way Python stores
  variables.
  """

def Restore(FileName):
    """Restore a previously saved game from disk"""

    #---------------------
    # Open Saved Game File
    #---------------------

    # We try and open the saved game, if we can't it's almost always
    # because the player hasn't saved one yet.

    try:
        SavedGame = open(FileName+".PSG","rb")
    except:
        Say(u"You haven't saved a game yet.")
        return FAILURE

    #-----------------------
    # Retrieve Global Object
    #-----------------------

    # Because of the nature of pickled objects, we have to manually restore each
    # and every property of each and every object Global refers to. To do that
    # successfully we need SavedObject to be a temporary copy.

    SavedObject = pickle.load(SavedGame)

    #-------------------------------------------
    # Restore all properties & objects in Global
    #-------------------------------------------

    # SavedObject has a dictionary that contains each and every
    # property in Global. In addition, it contains a reference to
    # each and every property of each and every object Global
    # referenced when it was saved...
    #
    # Notice FOR uses 2 variables instead of the normal 1. This is ok because
    # the items() method returns a tuple (group) of 2 objects. These two
    # variables are the ones required by the setattr function. Convenient, yes?

    for attr,value in SavedObject.__dict__.items():
        setattr(Global,attr,value)
        DebugTrace(u"Restoring "+attr)

    #----------------------
    # Close Saved Game File
    #----------------------

    # Just good programming practice to close what you open.

    SavedGame.close()

    #--------------------------------
    # Inform Caller Restore Succeeded
    #--------------------------------

    return SUCCESS

def Save(FileName):
    """Save the game in progress to disk"""

    #-------------------------
    # Erase Old Save Game File
    #-------------------------

    # FileName contains the name of the file we're going to save our
    # game into, for exmple TQ.PSG.

    # Since the file may already exist we try and delete it (which is
    # what os.remove() does).
    #
    # If the file DOES NOT exist already the attempt fails and the
    # EXCEPT clause kicks in. The PASS statement does nothing, it's
    # just a "place holder" since there's got to be at least one
    # statement following the EXCEPT. PASS was designed for cases like
    # this!
    #
    # The bottom line is, erase the file if it exists and if it doesn't
    # then don't do anything.
    #
    # By the way, PSG stands for PAWS Save Game.

    try:
        os.remove(FileName + ".PSG")
    except:
        pass

    #----------
    # Open File
    #----------

    # We need to create a new file to save our game in. The name of the
    # file is in FileName, by default it will be <game>.PSG,
    # for example "TQ.PSG".
    #
    # SavedGame becomes a reference to the open file.

    SavedGame = open(FileName+".PSG","wb")

    #-----------------
    # Create PickleJar
    #-----------------

    # PickleJar is just the object that does the pickling. We have to
    # tell it which file to dump the pickles into (SavedGame) and the
    # kind of pickling to use (Binary/Text).
    #
    # We're using Text pickling because it works, binary pickling has a bug that
    # causes it to fail. This is unfortunate because the binary version of the
    # file is much smaller (and unreadable by players!).

    PickleJar = pickle.Pickler(SavedGame,BINARY_PICKLE)

    #-------------------
    # Save Global Object
    #-------------------

    # By dumping the Global object into PickleJar we're *also* pickling
    # any objects Global references, which would include every
    # object in the game.

    try:
        PickleJar.dump(Global)
    except:
        print u"save error!"

    #----------------------
    # Close Saved Game File
    #----------------------

    # We're finished with the file, so now we have to make sure all
    # the information written to the file is actually on the hard
    # drive and not still in memory, this is what SavedGame.close()
    # REALLY does, in case you're curious.

    SavedGame.close()

    #--------------------------------
    # Inform Caller Restore Succeeded
    #--------------------------------

    return SUCCESS


def TranslateCBExpression(Text=""):
    """
    This function takes a string and translates any valid Python
    expression(s) enclosed within curly braces (the symbols { and }) into
    strings and returns the resulting string to the caller.
    """

    #---------------------------
    # Convert Text If Wrong Type
    #---------------------------

    # Text might not be a text variable, if it isn't then convert it into text.
    # repr() returns the "representation" of the object, in other words what
    # you'd get at the Python prompt if you tried to print it.

    if type(Text) != type(u""): Text = repr(Text)

    #-----------------------
    # Return Text If not CBE
    #-----------------------

    # If this isn't a CBE (Curly Brace Expression) we don't need to translate it,
    # return it as is.

    if u"{" not in Text or u"}" not in Text: return Text

    #-----------------------------------
    # Find { and } Positions Within Text
    #-----------------------------------

    # We need to find the position of the opening and closing curly braces in
    # Text. We'll use this information to replace only that portion of the
    # string with its translation.

    OpenBrace  = string.find(Text,u"{")
    CloseBrace = string.find(Text,u"}")

    #---------------------
    # Try To Translate CBE
    #---------------------

    # Because this is an arbitrary Python expression, and because this
    # function is part of the PAWS debugging system we have no
    # guarantee that the expression is valid. So we try to evaluate it
    # and if it works we then translate the result into a string.
    #
    # If it fails we set the result to "Invalid Curly Brace Expression,
    # Ignored" and continue on our merry way.

    try:
        Expr = eval(Text[OpenBrace+1:CloseBrace])
        if type(Expr) != type(u""): Expr = repr(Expr)
    except:
        Expr = u"Invalid CBE '%s'" % Text[OpenBrace+1:CloseBrace]


    #------------------------
    # Replace CBE With Result
    #------------------------

    # Here's an interesting bit of slicing and dicing. If you look
    # carefully you'll see we're taking the front part of text (up to
    # but NOT including the open brace), appending the result and the
    # end of Text following the closing curly brace. This neatly snips
    # out the CBE and replaces it with the result of the expression.
    #
    # Since we don't want to disturb the original Text (which might be
    # from anywhere) we put the result in ReturnValue.

    ReturnValue = Text[:OpenBrace] + Expr + Text[CloseBrace + 1:]


    #------------------------------
    # Handle CBE Resulting From CBE
    #------------------------------

    # Although you can't nest CBE's (have one CBE inside another), you
    # CAN have one CBE end up evaluating to another. That's why we
    # use the return value as the argument and call THIS SAME FUNCTION
    # again. It's called "recursion".
    #
    #
    # Here's how it might work. Let's say your description contains the
    # CBE {Clock.SoundDesc()}. The CBE evaluates to:
    #
    # "{ClockBird.SoundDesc()}". Obviously you don't want your players
    # seeing that! So the call below would translate the CBE AGAIN.
    #
    # This can occur any number of times and will properly translate.
    # It's unlikely to happen more than once or twice for any given
    # CBE however!

    ReturnValue = TranslateCBExpression(ReturnValue)


    #----------------------
    # Return Translated CBE
    #----------------------

    return ReturnValue

#********************************************************************************
#                             Hook Functions Into Engine
#
C="""
  We have functions (Save, Restore, and CBE Translation) that are vital to
  running your game successfully. The problem is the functions are defined
  here (in this file), but are needed there (in PAWS, Universe, and your
  game).

  PAWS contains the game engine, and is visible to every other file. The
  answer then is to "hook" our functions into the game engine. Once that's
  done the functions are visible to every file--including PAWS itself.

  This technique is used a great deal in PAWS, it's called "indirect
  referencing" and it's one of the things that makes Python such a simple
  and powerful language.
  """

Engine.RestoreFunction = Restore
Engine.SaveFunction = Save
Engine.XlateCBEFunction = TranslateCBExpression

#--- Set Play Module Version

C="""
  PlayModuleVersion is this module's version, which is valuable information
  since you pretty much want to keep the Engine, world library, and play
  module at the SAME version to avoid problems. While every effort is made
  to keep the three programs backwardly compatible, it's not always possible
  to do so.
  """

Global.PlayModuleVersion = u"2.1"

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#                             END OF TERMINAL SUPPORT CODE                      %
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
